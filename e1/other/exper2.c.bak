#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<pthread.h>
#include<time.h>
#include<pthread.h>
#include<semaphore.h>
#include<string.h>
#define __CLASS__ 1
#if __CLASS__

typedef struct Queue Queue;

typedef struct Queue{
	char queue[5];
	int num;
	void (*append)(Queue*,char);
	char (*get)(Queue*);
}Queue;
void attach(Queue *Que,char ch){
	*( Que->queue + Que->num )= ch;
	Que->num  += 1;
//	*(Que->queue + Que->num )= ch;
//	Que->num += 1;
}
char get(Queue *Que){
	char ch = *Que->queue ; 
	char temp[5] ;
	strcpy(temp,(Que->queue +1 )) ;
	memset(Que->queue,0,5*sizeof(char));
	strcpy(Que->queue,temp);
	Que->num -= 1;
	return ch;
//	*(Que->queue + Que->num )= '\0';
//	Que->num -= 1;
}
void init(Queue *Que){
	memset(Que->queue,0,5);
	Que->num = 0;
	Que->append = attach;
	Que->get = get;
}
Queue queue1,queue2;
#else
char queue1[5],queue2[5];
int p1=0,p2=0;
#endif

//#include"queue.h"
// mutex1用于队列1的互斥信号量
// mutex2用于队列2的互斥信号量
// space1,space2用于记录队列1,2剩余空间的数目的计数信号量
// num1，num2用于记录队列1,2的资源数目的计数信号量

sem_t mutex1,mutex2,space1,space2,num1,num2;

#define semWait(x) sem_wait(&x)
#define semSignal(x) sem_post(&x)
#define check(x) if( (x) != 0){printf("error,%d!\n",x); return -1;}
#define LOG(x) printf("\t\t\t\t\t\t\t\t%c running id:[%ld]\n"+ 4*((x=='A')?2:(x=='B')?1:0),x,pthread_self())
static inline void produce(char *ch){
	scanf("%s",ch);
	//getchar();
	//return ch;
}
/*take implemention*/
#if __CLASS__ 
static inline char take(Queue *que){
	printf("\t\t\t\ttake [%c] from Q1[%s]\n",*que->queue,que->queue);
	char ch = que->get(que);
	return ch;
}
#else
static inline char take(char* que1){

	char ch = *que1;
	printf("\t\t\t\ttake [%c] from Q1[%s]\n",*que1,queue1);
	*que1 = '\0';
	return ch;
}
#endif
/*append implemention*/
#if __CLASS__
static inline void append(Queue *que,char ch){
	que->append(que,ch);
}
#else
static inline void append(char *que,char ch){
	//strcpy(que,ch);
	*que = ch;
	*(que+1) = '\0';
}
#endif
/*consume implemention*/
#if __CLASS__
static inline void consume(Queue *que){
	printf("\t\t\t\t\t\t\t\tget [%c] from Q2 [%s]\n",*que->queue,que->queue);
	char ch = que->get(que);
}	
#else
static inline void consume(char *ch){
	printf("\t\t\t\t\t\t\t\tget [%c] from Q2 [%s]\n",*ch,queue2);
	*ch='\0';
}
#endif


void *threadA(void* param){
	char* ch = (char *)malloc(sizeof(char)*5);
	int i;
	while(1){
		LOG('A');
		produce(ch);
		if( *ch == 'q' ){
			printf("input nothing,A exited, which will cause B and C exit!\n");
			pthread_exit(NULL);
		}else{
			i = strlen(ch);
			printf("A input : [%s,%d]\n",ch,i);
		};
		while(i>0){
			semWait(space1);
			semWait(mutex1);
			
#if __CLASS__
			queue1.append( &queue1 , *(ch+i-1) );
			printf("append [%c] to Q1 [%s]\n",*(ch+i-1),queue1.queue);
#else
			sem_getvalue(&num1,&p1);
			append( (queue1 + p1),*(ch+i-1));
			printf("append [%c] to Q1 [%s]\n",*(ch+i-1),queue1);
#endif
			
			semSignal(mutex1);
			semSignal(num1);
			i --;
		};
	}
};
void *threadB(void* param){
	char ch ;
	while(1){
		LOG('B');
		/*take 1*/
		semWait(num1);
		semWait(mutex1);
		
#if __CLASS__
		ch = take(&queue1);
#else
		sem_getvalue(&space1,&p1);
		printf("\t\t\t\t%d\n",4-p1);
		ch = take( (queue1+ 4-p1) );
#endif
		semSignal(mutex1);
		semSignal(space1);
		/*produce 2*/
		semWait(space2);
		semWait(mutex2);
#if __CLASS__
		queue2.append(&queue2,(char)((int)ch-32));
		printf("\t\t\t\tappend [%c] to Q2 [%s]\n",ch,queue2.queue);
#else
		sem_getvalue(&num2,&p2);
		append((queue2 + p2),(char)( (int)ch - 32 ) );
		printf("\t\t\t\tappend [%c] to Q2 [%s]\n",ch,queue2);
#endif
		semSignal(mutex2);
		semSignal(num2);
	}
};
void *threadC(void* param){
	while(1){
		LOG('C');
		semWait(num2);
		semWait(mutex2);
#if __CLASS__
		consume(&queue2);
#else
		sem_getvalue(&space2,&p2);
		consume((queue2 + 4 - p2));
#endif
		
		semSignal(mutex2);
		semSignal(space2);
	}
};


int main(int argc,char *argv[]){
	/*Queue define*/
#if __CLASS__
	init(&queue1);
	init(&queue2);
#endif
	/*semaphore init*/
	int sas = 0;
	check( sem_init( &mutex1,0,1) );
	check( sem_init( &mutex2,0,1) );
	check( sem_init( &space1,0,5) );
	check( sem_init( &space2,0,5) );
	check( sem_init( &num1  ,0,0) );
	check( sem_init( &num2  ,0,0) );		
	/*thread init*/
	pthread_t A,B,C;
	check( pthread_create(&A,NULL,threadA,NULL) );
	check( pthread_create(&B,NULL,threadB,NULL) );
	check( pthread_create(&C,NULL,threadC,NULL) );
	/*wait thread exit*/
	/*if A exited, then B will exit, then C will exit*/
	check( pthread_join(A,NULL) );
	sleep(1);	
	check( pthread_cancel(B) );
	check( pthread_cancel(C) );
	/*semaphore destory*/
	check( sem_destroy( &mutex1 ) );
	check( sem_destroy( &mutex2 ) );
	check( sem_destroy( &space1 ) );
	check( sem_destroy( &space2 ) );
	check( sem_destroy( &num1   ) );
	check( sem_destroy( &num2   ) );
	return 0;
};


